void box_filter_3x3(const Image &in, Image &blury) {
	__m128i one_third = _mm_set1_epi16(21846);
	#pragma omp parallel for
	for (int yTile = 0; yTile < in.height(); yTile += 32) {
		__m128i a, b, c, sum, avg;
		__m128i blurx[(256/8)*(32+2)]; // allocate tile blurx array
		for (int xTile = 0; xTile < in.width(); xTile += 256) {
			__m128i *blurxPtr = blurx;
			for (int y = -1; y < 32+1; y++) {
				const uint16_t *inPtr = &(in[yTile+y][xTile]);
				for (int x = 0; x < 256; x += 8) {
				a = _mm_loadu_si128((__m128i*)(inPtr-1));
				b = _mm_loadu_si128((__m128i*)(inPtr+1));
				c = _mm_load_si128((__m128i*)(inPtr));
				sum = _mm_add_epi16(_mm_add_epi16(a, b), c);
				avg = _mm_mulhi_epi16(sum, one_third);
				_mm_store_si128(blurxPtr++, avg);
				inPtr += 8;
				}
			}
			blurxPtr = blurx;
			for (int y = 0; y < 32; y++) {
				__m128i *outPtr = (__m128i *)(&(blury[yTile+y][xTile]));
				for (int x = 0; x < 256; x += 8) {
					a = _mm_load_si128(blurxPtr+(2*256)/8);
					b = _mm_load_si128(blurxPtr+256/8);
					c = _mm_load_si128(blurxPtr++);
					sum = _mm_add_epi16(_mm_add_epi16(a, b), c);
					avg = _mm_mulhi_epi16(sum, one_third);
					_mm_store_si128(outPtr++, avg);
				}
			}
		}
	}
}
